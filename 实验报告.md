# 2048实验报告
---
不知道怎么写实验报告

## 构思
---
考虑最naive的做法，用4*4的棋盘储存数字，用一个while(true)的循环做主体，每次接收一个指令，然后根据指令（上下左右）移动/合并方块，最后统计分数。

## 主要操作逻辑
---
为了方便，我们把每个方块叫做Tile，每个Tile都是Tile类的一个实例，有position、color、number等属性，同时有指向QPushButton 和 QPropertyAnimation的指针。每个Tile有move()、addAnimation()等方法，其中move()函数接受一个方向参数，实现了对当前Tile在固定方向上的移动，这样只需要遍历board然后调用每个Tile的move()方法就可以实现不合并的移动了，实现了一层抽象（真的吗）

同时我们把当前局面也看成是一个GameState类的实例对象current_game_state，它包含了一个Size*Size的指针二维数组（指向Tile），目前得分和一个指向QLabel控件的指针。那么分数在合并的时候统计就可以了。

合并的实现使用了：移动->合并->移动的方法，具体说就是对每个Tile先让它move()，再在方向上寻找相邻且有相同number的Tile让它们合并。

## 键盘控制
---
这是一项QT特性。我们需要在Headers目录下的game2048（这里是项目的名字）.h文件内为主窗口类添加一个public的方法keyPressEvent(QKeyEvent* event)，再在Sources目录下的main.cpp中完成Game2048:: keyPressEvent(QKeyEvent* event)的函数主体就可以了。这里获得的按键值可以用event指针所指向类的key()方法访问到

一个小注意事项：由于本游戏使用QPushButton来实现Tile，因此上下左右键会被认为是Focus的改变而不能被MainWindow作为event接收到。解决方法很简单：1. 改用WASD控制 2. 对所有QPushButton设置Qt:: NoFocus

本游戏的设定是$\uparrow\leftarrow\downarrow\rightarrow$控制方块移动，Q保存局面，L读取已保存的局面，B撤回到上一个局面

## （并不）流畅的动画
---
每个Tile都是一个QPushButton。QT提供了QPropertyAnimation的类，只需要设置startValue和endValue、DurationTime就可以用start()方法让这个动画跑起来。这个的实现有点像Flash中的插入渐变帧

QT中还提供了若干动画曲线，只需要调用setEasingCurve()方法即可使用。为了实现更自然的动画这里选择了QEasingCurve:: OutQuad，可以看成是先加速最后缓慢减速至零

为了方便我把添加动画放在了Tile类的addAnimation()方法内，这样对于每个Tile只需要传入参数就可以添加动画了。

合并的动画是一个妙点。对于竖直方向的合并我实现了压扁的动画，水平方向的移动则用水平压扁的动画，这样看起来就更没有违和感

由于合并的实现使用了：移动->合并->移动的方法，而合并时立即删除了对应位置的Tile，因此会出现合并的Tile没有动画效果的情况
解决方法比较巧妙。我利用了一个queue储存被合并了的Tile的指针，在合并的时候给QPushButton新建一个完整的动画，然后把指针放在queue中。每次操作后再删除动画已经完成的Tile（这个东西显然是FIFO的）

最后还加上了产生新Tile时的由小到大的缩放动画，看起来就比较自然。由于比较懒因此原游戏中合并后放大再缩小的特效这里没有实现

## 存档/读档
---
用fstream打开文件，然后写入4*4+1的信息分别表示board内容和当前得分即可。读档的时候读取文件，把对应Tile还原再更新当前分就好了
本游戏的存档文件在游戏目录下的save.dat文件内，请勿随意更改（=_=）/

## 撤销操作
---
这个直接实现比较麻烦，但是我们用上了类和指针就比较方便了。因为当前局面是一个类的实例，因此我们可以用current_state指针来指向当前局面。每次操作时我们就令当前局面中的Tile全部隐藏，然后将当前局面复制一份记作tmp_state，那么后续的操作其实都是在对tmp_state进行的。

如果我们发现本次操作没有对游戏局面产生实质影响（指Tile的位置、数量、数字发生了变化），则删除tmp_state的局面，然后回退到current_state；
如果我们本次操作更改了游戏局面，则让current_state指向tmp_state，并将此时的current_state压入栈中。

那么回退就很简单了，只需要弹出栈顶，删除当前局面，再指向新的栈顶，显示即可。
注意到过多控件被new出来会影响内存的使用，因此我们在隐藏一个state的时候实际上要删除其中所有的QPushButton，毕竟其余信息都还在，后面还可以再new回来

还有一个问题出在类的复制这里。如果类中含有指针，那么类的默认复制函数只会复制指针，而不会复制指针所指向的内存空间中的内容。因此我们这里需要重写一个复制函数。类的复制函数、构造函数、析构函数都比较重要。。

## 颜色美化
---
为了显示出层次感，我使用了从2到8192各方块颜色逐渐加深的设定。这个非常好写，对控件的color属性设置RGB值就可以了

## 输赢判断
---
赢家判断很简单，原游戏的胜利标准是2048出现了，并且这时候还能继续玩下去。这个只需要在合并的时候判断一下新产生的数值就可以了，没有难度
输局也比较简单。如果board满了，**且不存在相邻相同的Tile**，那么说明下一步无路可走，于是输了。反之则一定不输


















